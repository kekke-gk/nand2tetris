class Board {
    static int W, H, SIZE;
    static int NEXTS_POS_X, NEXTS_POS_Y;
    static int SCREEN_HEIGHT;

    field Matrix board;
    field Mino mino;

    field int posX, posY;
    
    constructor Board new() {
        let W = 10;
        let H = 20;
        let SIZE = 12;
        let NEXTS_POS_X = 12;
        let NEXTS_POS_Y = 1;
        let SCREEN_HEIGHT = 256;

        let board = Matrix.new(W + 2, H + 1);
        do createWall();
        do spawnMino();
        return this;
    }

    method void spawnMino() {
        let mino = MinoGenerator.getMino();

        do drawNextMinos();

        do MinoGenerator.regenerate();

        if (mino.type() = 0) {
            let posX = 4;
        } else {
            let posX = 3;
        }

        let posY = 0;
        return;
    }

    method void createWall() {
        var int x, y;

        let x = -1;
        while (x < (W + 1)) {
            do set(x, H, true);
            let x = x + 1;
        }

        let y = 0;
        while (y < (H + 1)) {
            do set(-1, y, true);
            do set(10, y, true);
            let y = y + 1;
        }
        return;
    }

    method boolean at(int x, int y) {
        return board.at(x + 1, y);
    }

    method void set(int x, int y, boolean b) {
        do board.set(x + 1, y, b);
        return;
    }

    method int calcOffsetX(int x) {
        return (x + 1) * SIZE;
    }

    method int calcOffsetY(int y) {
        return y * SIZE;
    }

    method void drawPixel(int x, int y, boolean color) {
        var int offsetX, offsetY;

        let offsetX = calcOffsetX(x);
        let offsetY = calcOffsetY(y);

        do Screen.setColor(color);
        do Screen.drawRectangle(offsetX + 1, offsetY + 1, offsetX + SIZE - 1, offsetY + SIZE - 1);
        return;
    }

    method void drawBoard() {
        var int x, y;

        let x = -1;
        while (x < (W + 1)) {
            let y = 0;
            while (y < (H + 1)) {
                do drawPixel(x, y, at(x, y));
                let y = y + 1;
            }
            let x = x + 1;
        }
        return;
    }

    method void drawMino(Mino m, int px, int py, boolean drawOnlyBlack) {
        var int x, y;
        let x = 0;
        while (x < m.width()) {
            let y = 0;
            while (y < m.height()) {
                if (drawOnlyBlack) {
                    if (m.at(x, y)) {
                        do drawPixel(x + px, y + py, true);
                    }
                } else {
                    do drawPixel(x + px, y + py, m.at(x, y));
                }
                let y = y + 1;
            }
            let x = x + 1;
        }
        return;
    }

    method void drawCurrentMino() {
        do drawMino(mino, posX, posY, true);
        return;
    }

    method void eraseNextMinosArea() {
        var int offsetX, offsetY;
        let offsetX = calcOffsetX(NEXTS_POS_X);
        do Screen.setColor(false);
        do Screen.drawRectangle(offsetX, 0, offsetX + (SIZE * Mino.maxSize()), SCREEN_HEIGHT - 1);
        return;
    }

    method void drawNextMinos() {
        var int px, py, n;

        do eraseNextMinosArea();

        let n = 0;
        while (n < 4) {
            let px = NEXTS_POS_X;
            let py = NEXTS_POS_Y + (n * Mino.maxSize());
            do drawMino(MinoGenerator.getNextMino(n), px, py, true);
            let n = n + 1;
        }

        return;
    }

    method void draw() {
        do drawBoard();
        do drawCurrentMino();
        return;
    }

    method void setMovement(int key) {
        if (key = 65) { // A
            do mino.rotateL();
            if (detectCollision()) {
                do mino.rotateR();
            }
        }
        if (key = 68) { // D
            do mino.rotateR();
            if (detectCollision()) {
                do mino.rotateL();
            }
        }
        if (key = 130) { // left arrow
            let posX = posX - 1;
            if (detectCollision()) {
                let posX = posX + 1;
            }
        }
        if (key = 132) { // right arrow
            let posX = posX + 1;
            if (detectCollision()) {
                let posX = posX - 1;
            }
        }
        if (key = 131) { // up arrow
            do hardDrop();
        }
        if (key = 133) { // down arrow
            let posY = posY + 1;
            if (detectCollision()) {
                let posY = posY - 1;
            }
        }
        return;
    }

    method void drop() {
        let posY = posY + 1;
        if (detectCollision()) {
            do place();
            do eraseLines();
            do spawnMino();
        }
        return;
    }

    method void place() {
        var int x, y;
        let posY = posY - 1;

        let x = 0;
        while (x < mino.width()) {
            let y = 0;
            while (y < mino.height()) {
                if (mino.at(x, y)) {
                    do set(x + posX, y + posY, true);
                }
                let y = y + 1;
            }
            let x = x + 1;
        }

        return;
    }

    method void eraseLines() {
        var int x, y;
        var boolean isFullLine;
        var boolean isEmptyLine;

        let y = H - 1;
        while (~(y < 0)) {
            let isFullLine = true;
            let isEmptyLine = true;
            let x = 0;
            while (x < W) {
                if (at(x, y)) {
                    let isEmptyLine = false;
                } else {
                    let isFullLine = false;
                }
                let x = x + 1;
            }
            if (isFullLine) {
                do eraseLine(y);
            }
            if (isEmptyLine) {
                return;
            }

            let y = y - 1;
        }
        return;
    }

    method void eraseLine(int yErase) {
        var int x, y;
        var boolean isEmptyLine;

        let x = 0;
        while (x < W) {
            do set(x, yErase, false);
            let x = x + 1;
        }

        let y = yErase - 1;
        while (~(y < 0)) {
            let isEmptyLine = true;
            let x = 0;
            while (x < W) {
                if (at(x, y)) {
                    let isEmptyLine = false;
                }
                do set(x, y + 1, at(x, y));
                let x = x + 1;
            }
            if (isEmptyLine) {
                return;
            }
            let y = y - 1;
        }
        return;
    }

    method void hardDrop() {
        while (~detectCollision()) {
            let posY = posY + 1;
        }
        let posY = posY - 1;
        return;
    }

    method boolean detectCollision() {
        var int x, y;
        let x = 0;
        while (x < mino.width()) {
            let y = 0;
            while (y < mino.height()) {
                if (at(x + posX, y + posY) & mino.at(x, y)) {
                    return true;
                }
                let y = y + 1;
            }
            let x = x + 1;
        }
        return false;
    }

    method void dispose() {
        do board.dispose();
        do Memory.deAlloc(this);
        return;
    }

/*
      -7-6-5-4-3-2-1 0 1 2 3 4 5 6 7 8 9101112131415
 0    □□□□□□■□□□□□□□□□□■□□□□□
 1    □■■■■□■□□□□□□□□□□■□■■■■
 2    □■Hold■□■□□□□□□□□□□■□■Next■
 3    □■    ■□■□□□□□□□□□□■□■ 00 ■
 4    □■■■■□■□□□□□□□□□□■□■■■■
 5    □□□□□□■□□□□□□□□□□■□■■■■
 6    □□□□□□■□□□□□□□□□□■□■Next■
 7    □□□□□□■□□□□□□□□□□■□■ 01 ■
 8    □□□□□□■□□□□□□□□□□■□■■■■
 9    □□□□□□■□□□□□□□□□□■□■■■■
10    □□□□□□■□□□□□□□□□□■□■Next■
11    □□□□□□■□□□□□□□□□□■□■ 02 ■
12    □□□□□□■□□□□□□□□□□■□■■■■
13    □□□□□□■□□□□□□□□□□■□■■■■
14    □□□□□□■□□□□□□□□□□■□■Next■
15    □□□□□□■□□□□□□□□□□■□■ 03 ■
16    □□□□□□■□□□□□□□□□□■□■■■■
17    □□□□□□■□□□□□□□□□□■□□□□□
18    □□□□□□■□□□□□□□□□□■□□□□□
19    □□□□□□■□□□□□□□□□□■□□□□□
20    □□□□□□■■■■■■■■■■■■□□□□□
*/
}
